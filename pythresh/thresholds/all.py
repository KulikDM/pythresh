import warnings

import numpy as np
import scipy.stats as stats
from sklearn.utils import check_array

from .aucp import AUCP
from .base import BaseThresholder
from .boot import BOOT
from .chau import CHAU
from .clf import CLF
from .clust import CLUST
from .decomp import DECOMP
from .dsn import DSN
from .eb import EB
from .fgd import FGD
from .filter import FILTER
from .fwfm import FWFM
from .gesd import GESD
from .hist import HIST
from .iqr import IQR
from .mad import MAD
from .mcst import MCST
from .moll import MOLL
from .mtt import MTT
from .ocsvm import OCSVM
from .qmcd import QMCD
from .regr import REGR
from .thresh_utility import cut, normalize
from .wind import WIND
from .yj import YJ
from .zscore import ZSCORE


class ALL(BaseThresholder):
    """ALL class for Combined thresholder.

       Use the multiple thresholders as a non-parametric means
       to threshold scores generated by the decision_scores where outliers
       are set to any value beyond the (mean, median, or mode) of the
       contamination from all the combined thresholders.

       Parameters
       ----------

       thresholders : list, optional (default='all')
            List of instantiated thresholders, e.g. [DSN()]

       max_contam : float, optional (default=0.5)
            Maximum contamination allowed for each threshold output. Thresholded scores
            above the maximum contamination will not be included in the final combined
            threshold

       method : {'mean', 'median', 'mode'}, optional (default='mean')
           statistic to apply to contamination levels

           - 'mean':   calculate the mean combined threshold
           - 'median': calculate the median combined threshold
           - 'mode':  calculate the majority vote or mode of the thresholded labels

       random_state : int, optional (default=1234)
            Random seed for the random number generators of the thresholders. Can also
            be set to None.


       Attributes
       ----------

       thresh_ : threshold value that separates inliers from outliers

       confidence_interval_ : lower and upper confidence interval of the contamination level

    """

    def __init__(self, thresholders='all', max_contam=0.5, method='mean', random_state=1234):

        warnings.warn('''The ALL thresholder will be depreciated by version 0.3.1.
                      Use the COMB thresholder instead''',
                      category=DeprecationWarning, stacklevel=2)

        self.thresholders = thresholders
        self.max_contam = max_contam
        stat = {'mean': np.mean, 'median': np.median, 'mode': stats.mode}
        self.method = method
        self.method_func = stat[method]
        self.random_state = random_state

    def eval(self, decision):
        """Outlier/inlier evaluation process for decision scores.

        Parameters
        ----------
        decision : np.array or list of shape (n_samples)
                   which are the decision scores from a
                   outlier detection.

        Returns
        -------
        outlier_labels : numpy array of shape (n_samples,)
            For each observation, tells whether or not
            it should be considered as an outlier according to the
            fitted model. 0 stands for inliers and 1 for outliers.
        """

        decision = check_array(decision, ensure_2d=False)

        decision = np.sort(normalize(decision))

        # Initialize thresholders
        if self.thresholders == 'all':
            self.thresholders = [IQR(), MAD(), FWFM(), YJ(), ZSCORE(), AUCP(), QMCD(),
                                 FGD(), DSN(random_state=self.random_state), CLF(),
                                 FILTER(), WIND(random_state=self.random_state), EB(),
                                 REGR(random_state=self.random_state),
                                 BOOT(random_state=self.random_state),
                                 MCST(random_state=self.random_state), HIST(),
                                 MOLL(), CHAU(), GESD(), MTT(),
                                 OCSVM(random_state=self.random_state),
                                 CLUST(random_state=self.random_state),
                                 DECOMP(random_state=self.random_state)]

        # Apply each thresholder
        contam = []
        ratio = []
        counts = len(decision)

        for thresholder in self.thresholders:

            labels = thresholder.eval(decision)
            outlier_ratio = np.sum(labels)/counts

            if outlier_ratio < self.max_contam:

                contam.append(labels)
                ratio.append(outlier_ratio)

        contam = np.array(contam)
        ratio = np.array(ratio)

        # Get lower and upper confidence interval
        low, high = stats.bootstrap(ratio.reshape(1, -1),
                                    np.mean, paired=True,
                                    random_state=self.random_state).confidence_interval
        self.confidence_interval_ = [low, high]

        # Get [mean, median, or mode] of inliers
        if self.method == 'mode':

            self.thresh_ = None
            lbls = self.method_func(contam, axis=0)

            return np.squeeze(lbls[0])

        else:

            contam = np.sum(contam, axis=1)/contam.shape[1]
            inlier_ratio = 1-self.method_func(contam)

            idx = int(counts*inlier_ratio)
            limit = decision[idx] if idx < counts else 1.0
            self.thresh_ = limit

            return cut(decision, limit)
